{"Name":"Amazon Fire OS","Id":803,"Alias":"amazon-fireos","Description":"## Amazon Fire OS SDK\n\nTake advantage of the Amazon Fire OS platform by further integrating your Xamarin.Android apps to take advantage of more features!\n\n - **Amazon Maps** - Add interactive maps to your apps and delight users with custom overlays.\n - **Amazon GameCircle** - Sync your game data across devices and platforms to improve player experience and retention.\n - **Amazon In-App Purchases** Sell digital content and subscriptions including in-game currency and more, from within your apps.\n - **Amazon Device Messaging** - Amazon Device Messaging (ADM) lets you send push notifications from the cloud to Kindle Fire devices that run your app.\n \n### Learn More\nYou can learn more by visiting the [Official Documentation](https://developer.amazon.com/public/apis/).","Version":"1.0.0","Summary":"Create amazing apps by extending the Amazon Fire OS experience on Amazon Phones and Kindle Fire devices!","QuickStart":"## Amazon Developer Account \u0026 App Setup\n\nIf you do not already have an account, you should go to [Amazon Developer Console](https://developer.amazon.com/) and sign up.\n\nOnce your account is created and your are signed in, go to the [My Apps](https://developer.amazon.com/myapps.html) page and create a new Application.  Choose ***Android*** and click Next.  Enter a Title, and pick a Category.  When you are done, click Save and your app should be created.\n\n## Create a Security Profile and Generate an API Key\n\nSome of the API\u0027s require an ***APIKey*** to be generated.  API Key\u0027s are associated with a *Security Profile*.  Each app can be associated with a *Security Profile*.\n\n1. In your app\u0027s dashboard on the Developer Console, go to the ***Security Profile*** section, and click the *Create New Security Profile* button.\n\n2. On the next page, give your new profile a name and description, and Save it.\n\n3. Next, click the ***View Security Profile*** button for the newly created profile.\n\n4. Click the ***Android/Kindle Settings*** tab for the Security Profile.\n\n5. Enter a **Name** for a new API Key that you will generate shortly.\n\n6. Enter the **Package Name** of your app.  This package name ***must*** be exactly the same as the package name you setup in your Xamarin.Android app (in the *Project Settings -\u003e Android Application -\u003e Package Name* field)\n\n7. Find your app\u0027s MD5 Signature and paste it into the **Signature** field.  You can find your MD5 Signature by following this guide: [Finding your Keystore\u0027s MD5 or SHA1 Signature](http://developer.xamarin.com/guides/android/deployment,_testing,_and_metrics/MD5_SHA1/).\n8. Click ***Generate New Key***\n\n\nOnce your API Key has been generated, you will need to add it to your application\u0027s `AndroidManifest.xml` as metadata.  Copy the long **Key** string from the details page of the API Key you generated and add the following assembly attribute to your `AssemblyInfo.cs` file:\n\n```csharp\n[assembly: MetaData (\"APIKey\", Value=\"YOUR-API-KEY-HERE\")]\n```\n\nNOTE: In Amazon\u0027s documentation, it states you can add your API Key to a file named api_key.txt in your assets folder, however we have found this does not currently work in Xamarin.Android, so please use the [assembly: MetaData (..)] attribute instead!\n\n\n------------------------------------------------------------------\n\n\n# Getting Started with Amazon Maps\n\n### Developer Portal Maps Setup\nBefore you can use Maps in your app, you must setup your app on the Amazon Developer Portal and activate Maps functionality.\n\n1. In the *My Apps* section of the  Amazon Developer Portal, navigate to the App you have created and click the *Maps* section.\n\n2. Click the *Add Debug Registration* button.\n\n3. Enter the **Package Name** of your app (this must be identical to the package name in your Xamarin.Android app\u0027s Project Settings).\n\n4. Enter the MD5 Signature from your debug Keystore (you\u0027ve already done this in the *Generate an API Key* section above) into the **Debug Signature** field.\n\n5. Click *Submit*.\n\n\n### Setup your Android Manifest\nNext, you will need to add a few things to your `AndroidManifest.xml` file.\n\nFirst, add the following namespace declaration attribute to the `\u003cmanifest ... \u003e` tag:\n\n```xml\n\u003cmanifest xmlns:amazon=\"http://schemas.amazon.com/apk/res/android\" ... \u003e\n```\n\nNow, you can add the following tag inside of your `AndroidManifest.xml`\u0027s `\u003capplication\u003e...\u003c/application\u003e` tags:\n\n```xml\n\u003capplication\u003e\n\t\u003c!-- ... --\u003e\n\t\n\t\u003c!-- Enable Amazon Maps on Amazon devices. --\u003e\n\t\u003camazon:enable-feature android:name=\"com.amazon.geo.maps\" android:required=\"false\" /\u003e\n\t\u003c!-- ... --\u003e\n\u003c/application\u003e\n```\n\n### Adding Maps to your App\nThe Amazon Maps API is nearly identical to the Google Maps V1 API.  You can generally follow code samples for it and achieve the same results in Amazon Maps.\n\nTo add a map to your layout, use the following XML:\n\n```xml\n\u003ccom.amazon.geo.maps.MapView\n        android:id=\"@+id/mapview\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:layout_weight=\"1.0\"\n        android:enabled=\"true\"\n        android:clickable=\"true\" /\u003e\n```\n\n### Testing Maps\nTo Test maps on your device in Debug builds, you must be signed into the same Amazon Account on your Fire OS device that you used to register the app in the Developer Portal.  Go ahead and Make sure you are signed into your device with the same account now.\n\n\n\n\n\n\n\n\n\n\n\n-------------------------------------------------------------------\n\n# Getting Started with Amazon Device Messaging\n\n\nYour app needs to declare and use some special permissions for Amazon Device Messaging to work.  You can simply copy the assembly attributes below, into your `AssemblyInfo.cs` file in your own app:\n\n```csharp\n[assembly: Permission(Name=Constants.PackageNameReceivePermission, ProtectionLevel=Android.Content.PM.Protection.Signature)]\n[assembly: UsesPermission (Name=Constants.PackageNameReceivePermission)]\n[assembly: UsesPermission (Name=Constants.ReceivePermission)]\n[assembly: UsesPermission (Android.Manifest.Permission.WakeLock)]\n[assembly: UsesPermission (Android.Manifest.Permission.Internet)]\n[assembly: UsesFeature (Constants.AmazonDeviceMessagingFeature, Required = true)]\n```\n\nYou\u0027ll have to also make some modifications to the `AndroidManifest.xml` file manually.\n\nFirst, add the following namespace declaration attribute to the `\u003cmanifest ... \u003e` tag:\n\n```xml\n\u003cmanifest xmlns:amazon=\"http://schemas.amazon.com/apk/res/android\" ... \u003e\n\n```\n\nYou also need to declare that the app is using the specific device messaging feature.  To do so, you need to add the following tag inside of the `\u003capplication\u003e\u003c/application\u003e` tags:\n\n```\n\u003capplication\u003e\n\t\u003c!-- ... --\u003e\n\t\n\t\u003camazon:enable-feature android:name=\"com.amazon.device.messaging\" \n\t\t\t\t\t\t   android:required=\"false\" /\u003e\n\t\t\t\t\t\t   \n\t\u003c!-- ... --\u003e\n\u003c/application\u003e\n```\n\n\nNext, you need to add a Service and Broadcast Receiver implementation.  The easiest way to do this is to copy and paste the following code which subclasses some existing helper classes into a new file in your own project:\n\n```csharp\n[BroadcastReceiver (Permission = Constants.SendPermission)]\n[IntentFilter (new [] { Constants.ReceiveIntent, Constants.RegistrationIntent }, Categories = new [] { Constants.PackageName })]\npublic class MyAdmReceiver : ADMReceiver\u003cMyAdmService\u003e\n{\n}\n\t\n[Service]\npublic class MyAdmService : ADMService\n{\n\t[Preserve]\n\tpublic MyAdmService() : base()\n\t{\n\t}\n\n\tprotected override void OnMessage (Intent intent)\n\t{\n\t\tConsole.WriteLine (\"ADMService.OnMessage...\");\n\n\t\t// You will want to do something more intelligent here\n\n\t\tif (intent == null || intent.Extras == null)\n\t\t\tforeach (var key in intent.Extras.KeySet())\n\t\t\t\tConsole.WriteLine(\"Key: {0}, Value: {1}\", key, intent.GetStringExtra(key));\n\t}\n\n\tprotected override void OnRegistered (string registrationId)\n\t{\n\t\t// You probably want to inform your web service of this\n\t\tConsole.WriteLine (\"ADMService.OnRegistered: {0}\", registrationId);\n\t}\n\n\tprotected override void OnRegistrationError (string errorId)\n\t{\n\t\t// Error\n\t\tConsole.WriteLine (\"ADMService.Error: {0}\", errorId);\n\t}\n\n\tprotected override void OnUnregistered (string registrationId)\n\t{\n\t\tConsole.WriteLine (\"ADMService.OnUnRegistered: {0}\", registrationId);\n\t}\n}\n```\n\nYou will obviously need to add your own code to the overrides in `MyAdmService` to respond to Device Messaging events appropriately.\n\nFinally, you need to register for ADM in your app.  Usually you would do this once in the `OnCreate` of your main activity, or somewhere else once in the lifecycle of your application:\n\n```csharp\n// Check if ADM exists on this device (only works on Amazon devices)\nif (Constants.IsADMAvailable ()) {\n\tvar adm = new Amazon.Device.Messaging.ADM (this);\n\t\n\t// If we aren\u0027t already register, register\n\tif (string.IsNullOrEmpty (adm.RegistrationId))\n\t\tadm.StartRegister ();\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n-------------------------------------------------------------------\n\n# Getting Started with Amazon In-App Purchasing\n\n### Updating the Android Manifest\nYour app needs to receive broadcast intents from the Amazon Client via the ResponseReceiver class. You never use this class directly in your app. Instead, you simply include the following lines directly in the `\u003capplication\u003e\u003c/application\u003e` tags in the `AndroidManifest.xml` file for your app:\n\n\n```xml\n\u003capplication\u003e\n\n\t\u003c!-- ... --\u003e\n\t\n\t\u003creceiver android:name = \"com.amazon.inapp.purchasing.ResponseReceiver\" \u003e\n\t\t\u003cintent-filter\u003e\n\t\t\t\u003caction android:name = \"com.amazon.inapp.purchasing.NOTIFY\"\n\t\t    \tandroid:permission = \"com.amazon.inapp.purchasing.Permission.NOTIFY\" /\u003e\n\t\t\u003c/intent-filter\u003e\n\t\u003c/receiver\u003e\n\t\n\t\u003c!-- ... --\u003e\n\n\u003c/application\u003e\n```\n\n### Implement the Purchasing Observer\nOnce you have setup the ResponseReceiver to listen for broadcast intents from the Amazon Client, you need the ability to process the callbacks triggered from the ResponseReceiver. This is done with the `PurchasingObserver`. Your app can implement this by subclassing the `PurchasingObserver` abstract class.\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\tpublic IAPObserver (Activity iapActivity) : base (iapActivity)\n\t{\n\t}\n\n\tpublic override void OnGetUserIdResponse (GetUserIdResponse response)\n\t{\n\t\t// Got user response, ready for using the API\n\t}\n\n\tpublic override void OnItemDataResponse (ItemDataResponse response)\n\t{\n\t\t// Received response for request for item data\n\t}\n\n\tpublic override void OnPurchaseResponse (PurchaseResponse response)\n\t{\n\t\t// Received response for purchase\n\t}\n\n\tpublic override void OnPurchaseUpdatesResponse (PurchaseUpdatesResponse response)\n\t{\n\t\t// Received response about updates to purchases\n\t}\n\n\tpublic override void OnSdkAvailable (bool isSandboxMode)\n\t{\n\t\t// Received SDK available, ok to call some methods now\n\t}\n}\n```\n\n### Register the Purchasing Observer\nNext, register your PurchasingObserver with the PurchasingManager so that you can begin calling the In-App Purchasing API and receiving callbacks.  **This must be done in the `OnCreate(...)` method of your Main Activity.**\n\n```csharp\nvar observer = new IAPObserver (this);\nPurchasingManager.RegisterObserver (observer);\n```\n\nThe Purchasing Observer callback matching the register call is `OnSDKAvailable(...)`. The callback returns a boolean that you can check to see whether the app is running in test mode against SDKTester or in the live production environment.\n\n\n### Sync Access Rights for Current User\n\nDuring your Main Activity’s `OnResume()` method, retrieve the user Id of the customer currently logged into the Amazon Appstore by calling :\n\n```csharp\nPurchasingManager.InitiateGetUserIdRequest();\n```\n\nThe `PurchasingObserver.OnGetUserIdResponse` callback will be triggered in response to the `PurchasingManager.InitiateGetUserIdRequest()` call.\n\nThe first thing to do in the `PurchasingObserver.OnGetUserIdResponse` callback is to persist the user Id returned in the `GetUserIdResponse` object in memory.  This is the user Id of the customer currently logged into the Amazon Appstore.  As such, the user Id is unique to both the user and the app.\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n \n\tstring currentUserID = null;\n \n    public override void OnGetUserIdResponse (GetUserIdResponse response)\n    {\n        if (response.UserIdRequestStatus == \n        \tGetUserIdResponse.GetUserIdRequestStatus.Successful) {\n        \t\n\t\t\t// Save the current user id\n            currentUserID = response.UserId;\n            \n\t\t\t// Just use Offset.Beginning for consumables only app\n\t\t\tPurchasingManager.InitiatePurchaseUpdatesRequest (Offset.Beginning);\n        }\n        else {\n            // Fail gracefully.\n        }\n    }\n    \n\t//...\n}\n```\n\nNext, with the user returned, within the `PurchasingObserver.OnGetUserIdResponse()`, call `PurchasingManager.InitiatePurchaseUpdatesRequest()` with an offset value to retrieve the current state of receipts for your app’s entitlements and subscriptions. You must use this method to sync purchases made from other devices onto this device, and to sync revoked entitlements across all instances of your app.\n\n**NOTE:** Although the corresponding `PurchasingService.OnPurchaseUpdatesResponse()` callback will not return any consumable information, you must make a call to `PurchasingManager.InitiatePurchaseUpdatesRequest()` even if your app only contains consumable items.  In this case, it is `OnPurchaseResponse()` which will be returned to your app if there are any pending consumable purchases when `PurchasingManager.InitiatePurchaseUpdatesRequest()` is called.\n\nThe offset represents a position in a set of paginated results. You can use the offset to get the next set of results. You can also pass in `Offset.Beginning` to get the entire list of results.  Offset values are base64 encoded values and not human readable.\n\nIt is best practice to only query the system for updates ie. to only retrieve new receipts generated since the last call to `PurchasingManager.InitiatePurchaseUpdatesRequest()`.  Use the user Id returned above in from the `OnGetUserId` Response to retrieve the persisted offset and pass this in into the `PurchasingManager.InitiatePurchaseUpdatesRequest()`. You can use `Offset.Beginning` when making a call to `PurchasingManager.InitiatePurchaseUpdatesRequest()` in the consumable case.\n\n#### Consumables\nNo code needs to be added to the `PurchasingObserver.OnGetPurchaseUpdatesResponse()` callback if your app deals solely with consumables, since no receipt information will be sent back for Consumable purchases after their initial purchase.\n\n#### Entitlements\nWhen the `PurchasingObserver.OnGetPurchaseUpdatesResponse()` callback is triggered, process receipts returned by fulfilling and enabling all entitlements returned and process any revoked SKUs. First, check the request status returned in the `PurchaseUpdatesResponse.GetPurchaseUpdatesRequestStatus()`.\n \nIf the `requestStatus` is successful:\n\n - Retrieve all receipts and then fulfill/entitle them accordingly.\n - Only entitlements can be revoked. Call `PurchaseUpdatesResponse.GetRevokedSkus()` and remove entitlement to any SKUs returned in this call.\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n\t\n \tpublic override void OnPurchaseUpdatesResponse (PurchaseUpdatesResponse response)\n\t{\n\t\tvar requestStatus = response.GetPurchaseUpdatesRequestStatus ();\n\t\t\n\t\tif (requestStatus == \n\t\t\tPurchaseUpdatesResponse.PurchaseUpdatesRequestStatus.Successful) {\n\n\t\t\t// Check for revoked SKUs\n\t\t\tforeach (var sku in response.RevokedSkus) {\n\t\t\t\t// Revoke access to these SKUs\n\t\t\t}\n\n\t\t\t// Process receipts\n\t\t\tforeach (var receipt in response.Receipts) {\n\t\t\t\tif (receipt.ItemType == Item.ItemType.Entitled) {\n\t\t\t\t\t// Re-entitle customer to this SKU\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Provide the user access to any previously persisted entitlements\n\t\t}\n\t}\n\t\n\t// ...\n}\n```\n\n\n#### Subscriptions\n\nWhen the `PurchasingObserver.OnGetPurchaseUpdatesResponse()` callback is triggered, process receipts returned by fulfilling and enabling all subscriptions returned. First, check the request status returned in the `PurchaseUpdatesResponse.GetPurchaseUpdatesRequestStatus()`.\n \nIf the `requestStatus` is successful:\n\n - Retrieve all receipts and then fulfill/entitle them accordingly. Active subscriptions are denoted by a null end date in the receipt. Expired subscriptions are determined by a non-null end date on the receipt. It is your app\u0027s responsibility to manage expired subscriptions.\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n\t\n \tpublic override void OnPurchaseUpdatesResponse (PurchaseUpdatesResponse response)\n\t{\n\t\tif (response.GetPurchaseUpdatesRequestStatus () \n\t\t\t== PurchaseUpdatesResponse.PurchaseUpdatesRequestStatus.Successful) {\n\n\t\t\t// Check for revoked SKUs\n\t\t\tforeach (var sku in response.RevokedSkus) {\n\t\t\t\t// Revoke access to these SKUs\n\t\t\t}\n\n\t\t\t// Process receipts\n\t\t\tforeach (var receipt in response.Receipts) {\n\t\t\t\tif (receipt.ItemType == Item.ItemType.Subscription) {\n\t\t\t\t\t\n\t\t\t\t\t// Check subscription period for validity\n\t\t\t\t\tif (receipt.SubscriptionPeriod.EndDate == null) {\n\t\t\t\t\t\t// Grant access to the subscription\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Provide the user access to any previously persisted subscriptions\n\t\t}\n\t}\n\t\n\t// ...\n}\n```\n\n\n#### Handling the Offset\n\nIn both the entitlement and subscription case, when persisting the offset and returned receipts, they should be associated with the current user Id. This is to handle the case that multiple customers share the same physical device. The user Id returned in `GetPurchaseUpdatesResponse` can be used to for storing the receipt data and offset.\n\nIf `PurchaseUpdatesResponse.IsMore()` returns `true`, make a recursive call to `PurchasingManager.InitiatePurchaseUpdatesRequest()` with the value returned in `PurchaseUpdatesResponse.GetOffset()`.\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n\t\n \tpublic override void OnPurchaseUpdatesResponse (PurchaseUpdatesResponse response)\n\t{\n\t\tif (response.GetPurchaseUpdatesRequestStatus () \n\t\t\t== PurchaseUpdatesResponse.PurchaseUpdatesRequestStatus.Successful) {\n\n\t\t\tvar newOffset = response.Offset;\n\t\t\t\t\t\t\n\t\t\tif (response.IsMore) {\n\t\t\t\tPurchasingManager.InitiatePurchaseUpdatesRequest (newOffset);\n\n\t\t\t\t// Persist the offset for future use\n\t\t\t}\n\n\t\t} else {\n\t\t\t// Provide the user access to any previously persisted entitlements\n\t\t}\n\t}\n\t\n\t// ...\n}\n```\n\n#### Validate SKUs to be Used in Your App\nCalling `PurchasingManager.InitiateItemDataRequest()` allows you to retrieve the most up-to-date and localized price, title and description information for each of your SKUs. This must be done for all of the SKUs you are offering for sale within your app. Proper SKU validation will also prevent an invalid SKU status from being returned in the `PurchasingObserver.OnPurchaseResponse()`.\n\n```csharp\npublic class MainActivity : Activity {\n    \n    //  ...\n    \n    protected override void OnResume() {\n        // ...\n\t\tvar skuSet = new HashSet\u003cString\u003e();\n        skuSet.Add(\"com.amazon.example.iap.consumable\");\n        skuSet.Add(\"com.amazon.example.iap.entitlement\");\n        skuSet.Add(\"com.amazon.example.iap.subscription\");\n \n        PurchasingManager.InitiateItemDataRequest (skuSet);\n    }\n    \n    // ...\n}\n```\n\nThe `PurchasingObserver.OnItemDataResponse()` callback is triggered after the `PurchasingManager.IntiateItemDataRequest()` method has been called. You should check the request status returned in the `PurchaseUpdatesResponse.GetItemDataRequestStatus()` and only offer for sale purchasable items or SKUs validated by this call.\n \nIf the `status` is successful, retrieve the item data map (item type, icon url, localized price, title and description) keyed on sku for display in the app.\n \nIf the `status` is successful with unavailable SKUs, this indicates that the request was successful but item data for one or more of the provided SKUs was not available. Developers should retrieve the item data for each available sku for display in the app. Access to purchase should be degraded gracefully for any SKUs returned in `PurchaseUpdatesResponse.GetUnavailableSkus()`.\n \nIf the `status` is failed, you should disable IAP functionality in your app.\n\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n\t\n\tpublic override void OnItemDataResponse (ItemDataResponse response)\n\t{\n\t\tvar status = response.GetItemDataRequestStatus ();\n\n\t\tif (status == ItemDataResponse.ItemDataRequestStatus.SuccessfulWithUnavailableSkus) {\n\t\t\tforeach (var s in response.UnavailableSkus) {\n\t\t\t\t// Unavailable SKU: s\n\t\t\t}\n\t\t} else if (status == ItemDataResponse.ItemDataRequestStatus.Successful) {\n\t\t\tforeach (var key in response.ItemData.Keys) {\n\t\t\t\tvar item = response.ItemData [key];\n\t\t\t\t// Item is available\n\t\t\t}\n\t\t} else {\n\t\t\t// Fail gracefully\n\t\t}\n\t}\n\t\n\t// ...\n}\n```\n\n\n\n\n\n### Initiating In-App Purchase\n\nYou can now make a call to the In-App Purchasing API to initiate a purchase for a specific SKU.\n\nIf an item is purchased in your app, record the `requestId` from the `PurchaseResponse` object. From `OnPurchaseResponse()`, save the `requestId` found in the PurchaseResponse object to ensure that your app does not grant an item multiple times. Save the `RequestId` to a server or the device’s local storage.\n\nIf the item corresponding to the `requestId` has already been granted, the app does not need to take any action. Allowing the SDK to continue processing will remove the `Receipt` so that the same `Receipt` and `requestId` will not be sent to the app again.\n\nBefore your app grants an item to the customer, your app must verify that the item corresponding to the `requestId` has not already been granted.\n\nNote: The SKU used directly in the code here for simplicity but it is a best practice to store SKUs in resource file (e.g strings.xml) or to pull them from a server.\n\n```csharp\nvar requestId = PurchasingManager.InitiatePurchaseRequest (\"com.amazon.example.iap.consumable\");\n```\n\nThe matching `OnPurchaseResponse` callback contains all the information you need to verify the purchase.  **It is important that you make sure your code can handle the `OnPurchaseResponse` callback at any time while your app is running.**\n\nPurchase request status is has four possible values:\n\n - **Successful** - Indicating that the purchase was successfully completed.\n - **Failed** - Indicating that the purchase failed.\n - **InvalidSku** - Indicating that the SKU originally provided to the `PurchasingManager.InitiatePurchaseRequest(string)` method is not valid.\n - **AlreadyEntitled** - Indicating that the customer already owns the provided SKU.\n\nIf the Purchase request status is **Successful** then a receipt will be returned in the `PurchaseResponse`.\n\nEvery receipt will contain the item type, sku, subscription period, if the item type is a subscription and a PurchaseToken that can be used to validate a purchase via the Receipt Verification Service. The receipt is secure, and you can safely rely solely on it to authorize access to content or functionality within your app.\n\nThe `PurchaseToken` is dynamically generated each time receipt data is returned and is not a unique order identifier. They are unique values for out-of-app verification of the receipt with RVS.\n\nReceipt data is returned in the `PurchaseRsponse` object and will contain a purchase token. The PurchaseToken of a Receipt returned in a PurchaseResponse will be different than the PurchaseToken of a Receipt for the same user and sku returned in a PurchaseUpdatesResponse Regardless of the difference, each PurchaseToken will successfully validate against the Receipt Verification Service at any given time.\n\nReceipt processing in the successful `OnPurchaseResponse(...)` case differs between consumables, entitlements and subscriptions.\n\n\n#### Purchasing Consumables\nIn the consumable case, **this is the only time you will see a receipt**. You therefore must persist the relevant receipt data to allow you to provide the user with access to the consumable that they have purchased. Remember, consumable purchasable items are only valid for the user on the device that it was purchased on.\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n\t\n\tpublic override void OnPurchaseResponse (PurchaseResponse response)\n\t{\n\t\tvar status = response.GetPurchaseRequestStatus ();\n\t\t\n\t\tif (status == PurchaseResponse.PurchaseRequestStatus.Successful) {\t\t\n\n\t\t\tvar receipt = response.Receipt;\n\t\t\t\n\t\t\tConsole.WriteLine (\"{0}: {1}, {2}\", \n\t\t\t\treceipt.Sku, receipt.ItemType, receipt.PurchaseToken);\n\n\t\t\t// Store receipt and enable access to consumable\t\t\t\n\t\t}\n\t}\n\t\n\t// ...\n}\n```\n\n\n#### Purchasing Entitlements\n\nFor entitlements, the receipt parsing code is the same as for consumables.\n\n\n\n#### Purchasing Subscriptions\n\nFor subscriptions, an additional parameter will be returned inside the `Receipt` object - the `SubscriptionPeriod`. The `SubscriptionPeriod` object contains a start date and an end date representing the period of time during which a subscription is valid. If a subscription is valid, it will have a null end date. If the subscription has expired, the end date will contain the date that the subscription is no longer valid.\n\n\n```csharp\npublic class IAPObserver : PurchasingObserver \n{\n\t// ...\n\t\n\tpublic override void OnPurchaseResponse (PurchaseResponse response)\n\t{\n\t\tvar status = response.GetPurchaseRequestStatus ();\n\t\t\n\t\tif (status == PurchaseResponse.PurchaseRequestStatus.Successful) {\t\t\n\n\t\t\tvar receipt = response.Receipt;\t\t\n\t\t\tvar subPeriod = receipt.SubscriptionPeriod;\n\t\t\t\n\t\t\tConsole.WriteLine (\"{0}: {1}, {2}\", \n\t\t\t\treceipt.Sku, receipt.ItemType, receipt.PurchaseToken);\n\n\t\t\tif (subPeriod.EndDate == null) {\t\t\n\t\t\t\t// Entitle subscription\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ...\n}\n```\n\n\n\n\n### Testing your App with SDK Tester\nIt\u0027s important to note that there are some specific steps and setup you must go through in order to be able to test debug builds of your app with the In-App Purchasing API.\n\nYou can find the full guide to using the SDK Tester here: [Testing In-App Purchases](https://developer.amazon.com/public/apis/earn/in-app-purchasing/docs/testing-iap).\n\n**NOTE**: You will need to download the full Mobile SDK from Amazon to get the SDKTester.apk tool.  You can find that SDK here: [Amazon Mobile SDK](https://developer.amazon.com/public/resources/development-tools/sdk).\n\n### Receipt Validation\nIt\u0027s possible to validate your receipts.  To do this, you would use RVS (Receipt Verification Service).  There\u0027s a full guide on how to implement RVS and how to test it here: [Receipt Verification Service Implementation and Testing](https://developer.amazon.com/public/apis/earn/in-app-purchasing/docs/rvs)\n\n\n\n\n\n\n\n\n\n\n\n-------------------------------------------------------------------\n\n# Getting Started with Amazon GameCircle\n\n\nFirst, you should follow the [Get Set Up for GameCircle](https://developer.amazon.com/public/apis/engage/gamecircle/docs/get-set-up-for-gamecircle).  This will help you with configuring your GameCircle game in the Developer Console (defining achievements, leaderboards, and test accounts).\n\nWhen you have completed the guide, continue below.\n\n## Initializing GameCircle on Android / Fire OS\n\nYou will need to add a couple permissions to your app.  You can do this by editing the `AndroidManifest.xml` file or by including the following assembly level attributes in you C# code:\n\n```csharp\n[assembly: UsesPermission (Android.Manifest.Permission.Internet)]\n[assembly: UsesPermission (Android.Manifest.Permission.AccessNetworkState)]\n```\n\nIn order to fully leverage built in GameCircle UI\u0027s, we need to add some information manually to our `AndroidManifest.xml` to register Amazon\u0027s activities and broadcast receivers so the SDK can work fully.\n\nFor targeting Android API Levels 11 and above, add this to your `AndroidManifest.xml` file, inside the `\u003capplication\u003e...\u003c/application\u003e` tags (**NOTE**: You must replace the `YOUR_PACKAGE_NAME_HERE` in the snippet below with your own Package Name):\n\n```xml\n\u003cactivity android:name=\"com.amazon.ags.html5.overlay.GameCircleUserInterface\"\nandroid:theme=\"@style/GCOverlay\" android:hardwareAccelerated=\"false\"\u003e\u003c/activity\u003e\n\u003cactivity\n  android:name=\"com.amazon.identity.auth.device.authorization.AuthorizationActivity\"\n  android:theme=\"@android:style/Theme.NoDisplay\"\n  android:allowTaskReparenting=\"true\"\n  android:launchMode=\"singleTask\"\u003e\n  \u003cintent-filter\u003e\n     \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n     \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n     \u003ccategory android:name=\"android.intent.category.BROWSABLE\" /\u003e\n     \u003cdata android:host=\"YOUR_PACKAGE_NAME_HERE\" android:scheme=\"amzn\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/activity\u003e\n\u003cactivity android:name=\"com.amazon.ags.html5.overlay.GameCircleAlertUserInterface\"\nandroid:theme=\"@style/GCAlert\" android:hardwareAccelerated=\"false\"\u003e\u003c/activity\u003e\n\u003creceiver\n  android:name=\"com.amazon.identity.auth.device.authorization.PackageIntentReceiver\"\n  android:enabled=\"true\"\u003e\n  \u003cintent-filter\u003e\n     \u003caction android:name=\"android.intent.action.PACKAGE_INSTALL\" /\u003e\n     \u003caction android:name=\"android.intent.action.PACKAGE_ADDED\" /\u003e\n     \u003cdata android:scheme=\"package\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/receiver\u003e\n```\n\nFor targeting Android API Levels 10 and below add this *instead*.  The differences are to do with hardware acceleration differences between the API levels (**NOTE**: You must replace the `YOUR_PACKAGE_NAME_HERE` in the snippet below with your own Package Name):\n```xml\n\u003cactivity android:name=\"com.amazon.ags.html5.overlay.GameCircleUserInterface\"\nandroid:theme=\"@style/GCOverlay\"\u003e\u003c/activity\u003e\n\u003cactivity\n  android:name=\"com.amazon.identity.auth.device.authorization.AuthorizationActivity\"\n  android:theme=\"@android:style/Theme.NoDisplay\"\n  android:allowTaskReparenting=\"true\"\n  android:launchMode=\"singleTask\"\u003e\n  \u003cintent-filter\u003e\n     \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n     \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n     \u003ccategory android:name=\"android.intent.category.BROWSABLE\" /\u003e\n     \u003cdata android:host=\"YOUR_PACKAGE_NAME_HERE\" android:scheme=\"amzn\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/activity\u003e\n\u003cactivity android:name=\"com.amazon.ags.html5.overlay.GameCircleAlertUserInterface\"\nandroid:theme=\"@style/GCAlert\"\u003e\u003c/activity\u003e\n\u003creceiver\n  android:name=\"com.amazon.identity.auth.device.authorization.PackageIntentReceiver\"\n  android:enabled=\"true\"\u003e\n  \u003cintent-filter\u003e\n     \u003caction android:name=\"android.intent.action.PACKAGE_INSTALL\" /\u003e\n     \u003caction android:name=\"android.intent.action.PACKAGE_ADDED\" /\u003e\n     \u003cdata android:scheme=\"package\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/receiver\u003e\n```\n\n### Initialize and Dispose the GameCircle client\n\n```csharp\nAmazonGamesClient agsClient;\n\n// List of features your game uses (only add those you need)\nJava.Util.EnumSet gameFeatures = Java.Util.EnumSet.Of(AmazonGamesFeature.Achievements,\n\tAmazonGamesFeature.Leaderboards, AmazonGamesFeature.Whispersync);\n\nprotected override void OnResume ()\n{\n\tbase.OnResume ();\n\n\tAmazonGamesClient.Initialize (this, new AmznGamesCallback {\n\t\tServiceNotReadyAction = status =\u003e {\n\t\t\t// Unable to use service\n\t\t},\n\t\tServiceReadyAction = client =\u003e {\n\t\t\tagsClient = client;\n\n\t\t\t// Ready to use GameCircle\n\t\t}\n\t}, gameFeatures);\n}\n\nprotected override void OnPause ()\n{\n\tbase.OnPause ();\n\n\t// Dispose this instance of the client when we are done with it\n\t// to prevent measuring the customer\u0027s time played while in the background\n\tif (agsClient != null) {\n\t\tagsClient.Dispose ();\n\t\tagsClient = null;\n\t}\n}\n\nprotected override void OnDestroy ()\n{\n\tbase.OnDestroy ();\n\n\t// Shutdown the client when we are completely done with it\n\tAmazonGamesClient.Shutdown ();\n}\n\npublic class AmznGamesCallback : Java.Lang.Object, IAmazonGamesCallback\n{\n\tpublic Action\u003cAmazonGamesStatus\u003e ServiceNotReadyAction { get; set; }\n\tpublic Action\u003cAmazonGamesClient\u003e ServiceReadyAction { get; set; }\n\n\tpublic void OnServiceNotReady (AmazonGamesStatus status)\n\t{\n\t\tif (ServiceNotReadyAction != null)\n\t\t\tServiceNotReadyAction (status);\n\t}\n\n\tpublic void OnServiceReady (AmazonGamesClient client)\n\t{\n\t\tif (ServiceReadyAction != null)\n\t\t\tServiceReadyAction (client);\n\t}\n}\n```\n\n\n## Implementing Whispersync\n\nWith Whispersync, you get and set values in a data map. It is the first solution to offer both auto-conflict resolution and player-choice conflict resolution as options, and it queues when a device is offline. You can set up the data map in just a few minutes.\n\nThe GameCircle SDK incorporates the Login with Amazon service to manage Whispersync authentication.\n\n### How Whispersync for Games Works\n\nPrior to Whispersync for Games, many developers implemented separate methods to store game data to disk and to cloud. Whispersync replaces your local storage solution and provides the added benefit of background synchronization with the cloud and Android and iOS devices.\n\nWith the `GameDataMap` interface, you get and set numbers and strings, and organize them in lists and maps. `GameDataMap` is a first-class citizen that you can treat as a variable, pass into a method, or return from a method.\n\nHere’s how you get your game data:\n\n```csharp\nvar gameDataMap = AmazonGamesClient.WhispersyncClient.GameData;\n```\n\nUnlike the GameCircle leaderboard and achievements clients, the Whispersync client is available immediately after initializing `AmazonGamesClient`. Whispersync data is always accessible, even when the player is not registered with Amazon or is offline.\n\n`GameDataMap` provides several ways to access your data. For example, to retrieve a player’s highest score:\n\n```csharp\nvar highScore = gameDataMap.GetHighestNumber (\"highScore\");\n```\n\nIn this example, because you retrieve highScore as a highest number, it will always reflect the maximum value ever assigned to it, from any device.\n\nTo set the high score:\n\n```csharp\n// Where 1000 represents a player\u0027s score, not a maximum\nhighScore.Set(1000);\n```\n\n### Conflict Resolution Options\n\nAmazon offers two conflict resolution options to provide the best possible player experience for each game:\n\n - **Auto resolution**, in which your game automatically syncs the best score (highest or lowest, depending on the game), most recent achievements, and most recent purchases across all devices and to the Amazon cloud, without further action on both the player and the developer’s part. To implement auto-conflict resolution, use any of the Whispersync data type described below, except for DeveloperString (which is used exclusively for manual conflict resolution).\n\n - **Manual resolution via DeveloperString**, in which the developer manually performs the conflict resolution. You should first get and deserialize both locally and remotely stored strings, and then set specific values via game logic to determine the current game state. If there is no easy way to auto-resolve, you can optionally prompt the player for input.\n \nFor implementation details of manual resolution via DeveloperString, see Example 4 below.\n\n**IMPORTANT:** Amazon recommends that you exercise caution with manual resolution via DeveloperString. Your game logic may differ from players’ expectations. For example, if a player buys an item for 100 Coins on offline Device A, and later buys a different item with the same 100 Coins on offline Device B, the player may want to keep the item from Device A, which represents the older data. In this case, it may be best to involve the player via a popup to let them decide which item they would rather keep. Alternatively, you may choose to model the above situation with auto-resolvable types such as `SyncableAccumulatingNumber` and `SyncableStringSet`.\n\n\nYou should read the guide: [Implementing Whispersync for Games in your Android or Fire OS game](https://developer.amazon.com/public/apis/engage/gamecircle/docs/whispersync) for more information.\n\n\n\n\n## Implementing Achievements\n\n### Send an Achievement Update\n\nAfter initializing Amazon GameCircle in your game, you can submit achievement progress updates to the service.\n\nThe second input parameter to the `UpdateProgress\u0027 method is a floating-point value representing the player’s completion percentage for the achievement.  The valid range of this parameter is `0.0` to `100.0`, where `0.0` represents ***fully locked*** and `100.0` represents ***fully unlocked***.  Completion percentage can only increase. If the method submits a completion percentage value that is lower than the current value, the completion percentage shown for that achievement will not change. \n\n```csharp\n// Replace YOUR_ACHIEVEMENT_ID with an actual achievement ID from your game.\nvar acClient = agsClient.AchievementsClient;\n\nacClient.UpdateProgress (YOUR_ACHIEVEMENT_ID, 100.0f);\n```\n\n\n### Add a Link to the Achievement Overlay in Your Game\n\nTo help customers find their achievements, make sure to add a link somewhere in your game to the in-game overlay.\n\n```csharp\nButton btnAchievementsOverlay;\n\n// ...\n\nbtnOpenAchievementsOverlay.Click += delegate {\n\tagsClient.AchievementsClient.ShowAchievementsOverlay ();\n};\n```\n\n### Get a List of Achievements\nThe achievements client can generate a list of the player\u0027s achievements in your game.  Notice that the `AGResponseHandler\u003cT\u003e` is used to register for a callback.  This pattern is used commonly in the GameCircle clients.\n\n```csharp\nagsClient.AchievementsClient.GetAchievements ()\n\t.SetCallback (new AGResponseHandler\u003cIGetAchievementssResponse\u003e (response =\u003e {\n\t\tforeach (var achievement in response.Achievements) {\n\t\t\tConsole.WriteLine (\"Found Achievement: {0}\", achievement.Title);\n\t\t}\n\t}));\n```\n\n\n\n## Implementing Leaderboards\n\n### Submitting a score to a Leaderboard\nAfter initializing Amazon GameCircle in your game, you can submit scores to the service. Scores must be positive numbers.\n\n```csharp\nagsClient.LeaderboardsClient.SubmitScore (YOUR_LEADERBOARD_ID, longScoreValue);\n```\n\n### Add a Link to the Leaderboards Overlay in Your Game\nTo help customers find the leaderboard, make sure to add a link to the in-game overlay somewhere in your game.\n\n```csharp\nButton btnLeaderboardsOverlay;\n\n// ...\n\nbtnOpenLeaderboardsOverlay.Click += delegate {\n\tagsClient.LeaderboardsClient.ShowLeaderboardsOverlay ();\n};\n```\n\n\n### Get a List of Leaderboards\nThe leaderboards client can generate a list of leaderboards in your game.  Notice that the `AGResponseHandler\u003cT\u003e` is used to register for a callback.  This pattern is used commonly in the GameCircle clients.\n\n```csharp\nagsClient.LeaderboardsClient.GetLeaderboards ()\n\t.SetCallback (new AGResponseHandler\u003cIGetLeaderboardsResponse\u003e (response =\u003e {\n\t\tforeach (var leaderboard in response.Leaderboards) {\n\t\t\tConsole.WriteLine (\"Found Leaderboard: {0}\", leaderboard.Name);\n\t\t}\n\t}));\n```\n\n\n\n","Hash":"874ab0413755eb34e9319836df036e8e","TargetPlatforms":["android"],"TrialHash":null}